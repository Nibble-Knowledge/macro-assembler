#a comment
NND lit[F]
NND N_[F]
#Trying a nested Macro
NND N_[F]
ADD N_[1]
#The carry macro
CXA 0
NND N_[1]
NND N_[F]

#simple acc stuff - being exhaustive in my tests
ADD N_[1]
ADD N_[F]

#shifts
STR macro[0]
ADD macro[0]

STR macro[0]
ADD macro[0]
STR macro[0]
CXA 0
NND N_[1]
NND N_[F]
ADD macro[0]
label:

#unary macros! Testing simple first
LOD lit[f]
STR place[0]

#testing that the math works
LOD place[3]
STR elsewhere[a]
LOD place[4]
STR elsewhere[b]
LOD place[5]
STR elsewhere[c]
LOD place[6]
STR elsewhere[d]
LOD place[7]
STR elsewhere[e]
LOD place[8]
STR elsewhere[f]
LOD place[9]
STR elsewhere[10]
LOD place[a]
STR elsewhere[11]
LOD place[b]
STR elsewhere[12]
LOD place[c]
STR elsewhere[13]
LOD place[d]
STR elsewhere[14]
LOD place[e]
STR elsewhere[15]
LOD place[f]
STR elsewhere[16]
LOD place[10]
STR elsewhere[17]
LOD place[11]
STR elsewhere[18]
LOD place[12]
STR elsewhere[19]

#does recursion between acc and unary work?
LOD somewhere[1f]
NND N_[F]
STR place[0]

#more complex recursion - 8-bit negations!
LOD source[0]
NND N_[F]
STR dest[0]
LOD source[1]
NND N_[F]
ADD N_[1]
STR dest[1]
CXA 0
NND N_[1]
NND N_[F]
ADD dest[0]
STR dest[0]

#test addition
#ADD8 num othernum INTO sum

#subtraction uses lots of macro memory
#SUB32 firstop secondop INTO dest

;alternate comment syntax
;jump macros?
#JMPEQ place N_[f] TO label
