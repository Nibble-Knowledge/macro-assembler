	Accumulator Macros

NOT 	- bitwise complement
NEG		- 2's complement negation
LOGNOT	- boolean negation (nonzero becomes zero, zero becomes nonzero)
GETCARR	- isolates the carry bit from the status register
GETCMP	- isolates the 2'c complement comparison bit from status register
INC		- increments (adds 1)
DEC		- decrements (subtracts 1)
LSHIFT	- left shift by 1, filling LSB with 0.
LROT	- left rotate by 1, filling LSB with old MSB
SIGNEX	- if MSB is 1, puts F into ACC. Otherwise, puts 0 into ACC.
BEEP	- Tells the audio peripheral, if present (and enabled by 0xD)
		- to make a sound corresponding to the accumulator contents.
		- Beep with acc value 0 tells it to be quiet.

	Normal Unary Macros (OPCODE mem1 INTO mem2)

MOV		- copies memory, without altering it
NOT		- bitwise complement
NEG		- 2's complement negation
INC		- Increment (add 1).
LSHIFT	- left shift by 1
LROT	- left rotate by 1

	Normal Binary Macros (OPCODE mem1 mem2 INTO mem3)

ADD		- basic addition with carry
SUB		- subtraction, with carry (mem3 = mem1 - mem2)
NAND	- bitwise NAND
AND		- bitwise AND
OR		- bitwise OR
NOR		- bitwise NOR
XOR		- bitwise XOR
XNOR	- bitwise XNOR

	Jump Macros (OPCODE mem1 mem2 TO code1) - not fully tested yet

JMPEQ	- jump if memory locations hold equal contents
JMPNE	- jump if memory locations hold different contents

	Syntactic Requirements

To simplify the core of the macro expander, certain constraints
have been placed on syntax. In general, only one statement can
be on each line. User-defined jump labels shown in code
must be on a line with nothing else, and must end with a colon
("myLabel:", for instance). Labels can, however, share a line
with a data field declaration. Line comments are marked with a 
leading hash ('#') or semicolon (';'), and cannot be on the 
same line as anything else.

In unary and binary macros, the "INTO" and final label can be
omitted. If this is done, it will assume you meant "INTO mem1",
and put the result of the operation into the first memory location
given. For example, "NEG8 number" is equivalent to "NEG8 number
INTO number".

Blank lines and line comments are both unaltered by this program,
meaning that the output code will be slightly easier to read and
debug. This was done not only for your benefit, but also for mine.
Allowing comments to pass through means that I will have a much
easier time testing and debugging this program!

	Macro Variations

All normal unary and binary macros have size variants, for
8, 16, 32, and 64 bit operand sizes. They are used by appending
the size to the opcode. For example, ADD32 or LSHIFT8 are also
valid opcodes. Assumes less significant bits have higher memory
addresses.

Labels can be offset by a hexadecimal value (no need for the
0x prefix, though it doesn't break anything), which signifies
a memory position that many nibbles "further" (greater address
value) in memory. For instance, if place[0] has previously been
used to MOV16 the value 0xC0DE, then place [2] now holds the
value "D".

The &(label[A])[B] syntax is supported by this program, but with
the requirement that both offsets be present at all times, even if
their values are 0. If the second offset has a value greater than 3,
this will cause a syntax error, as this indicates the fifth (or greater)
bit of an address, which is meaningless.

	Special Macros

These were designed for use by other macros, but are available
to use in your programs if you want.

ADDC	- binary macro. Requires that ACC hold previous carry.
		Propagates addition, and sets ACC to hold output carry.
		Note that this may not be the same as the STAT carry;
		the one in the ACC is correct.

PROPCARR- unary macro. Adds the carry bit from STAT to the first
		operand, and stores the result in the second operand.

MOVADDR	- puts address of mem1 into mem2 (as C '&' operator). No
		variants available, but very useful for subroutine calls.

	File Inclusion

We can now handle file inclusion. Files are opened and expanded
in a breadth-first recursive manner, automatically ignoring any
repeated files. Files can be included by using an INCL opcode
followed by a valid filepath to the new file. Files will be 
concatenated in a way that keeps each code section intact, as
well as keeping each data section intact. It will, however, cause
other code and/or data to be inserted between the last instruction
in the file and the first data declaration in the file. Comments
are generated in a way that allows easy traceability of which file
a particular line of code originated from.

	Absurd Levels of Detail - these are still somewhat volatile

Not all math macros leave the status register in a useful state.
In fact, it's safe to assume multi-nibble ones don't. Instead,
some of them leave a carry in the ACC. Here's a list of macros
that (in 8-bit or larger) leave a carry in ACC:

ADD 
INC 
NEG 
LSHIFT (but not LROT)


